import { supabase } from "./supabase-client.js";

const CLOUD_KEY = "localStorage_dump_v1";
const CLOUD_HISTORY_PREFIX = `${CLOUD_KEY}:history:`;
const CLOUD_HISTORY_KEEP_COUNT = 30;
const LAST_SYNC_USER_KEY = "tsms_last_sync_user_id";
const SYNC_KEYS = [
  "tsms_reports",
  "tsms_reports_archive",
  "ops",
  "ops_archive_v1",
  "tsms_settings",
  "tsms_sales_plan",
  "tsms_sales_manual_v1",
  "tsms_sales_manual_mode",
  "tsms_sales_reset_token",
  "tsms_report_current_day",
  "tsms_holidays_jp_v1",
  "tsms_theme"
];

let autoSyncInstalled = false;
let debounceMs = 5000;
let debounceTimer = null;
let inFlight = false;
let pendingAfterFlight = false;
let dirtySinceLastBackup = false;
let syncPaused = false;
let inFlightPromise = null;

function currentPageName() {
  try {
    const p = (location.pathname || "").split("/").pop();
    return p || "index.html";
  } catch (_) {
    return "";
  }
}

function shouldFlushOnPageLeave() {
  const page = currentPageName();
  return page === "confirm.html" || page === "sales.html" || page === "ops.html";
}

function safeJsonParse(raw, fallback) {
  try {
    return JSON.parse(raw);
  } catch (_) {
    return fallback;
  }
}

function summarizePayload(payload) {
  const keys = Object.keys(payload || {});
  const reports = safeJsonParse(payload?.tsms_reports || "[]", []);
  const archive = safeJsonParse(payload?.tsms_reports_archive || "[]", []);
  return {
    keyCount: keys.length,
    keys,
    reportCount: Array.isArray(reports) ? reports.length : 0,
    archiveCount: Array.isArray(archive) ? archive.length : 0,
    currentDayId: String(payload?.tsms_report_current_day || "")
  };
}

async function getCurrentUserId() {
  try {
    const { data } = await supabase.auth.getUser();
    return String(data?.user?.id || "");
  } catch (_) {
    return "";
  }
}

function buildHistoryKey() {
  const iso = new Date().toISOString().replace(/[^\dTZ]/g, "");
  const rand = Math.random().toString(36).slice(2, 8);
  return `${CLOUD_HISTORY_PREFIX}${iso}_${rand}`;
}

async function pruneCloudHistory() {
  const { data, error } = await supabase
    .from("app_state")
    .select("key,updated_at")
    .like("key", `${CLOUD_HISTORY_PREFIX}%`)
    .order("updated_at", { ascending: false });

  if (error || !Array.isArray(data)) return;
  if (data.length <= CLOUD_HISTORY_KEEP_COUNT) return;

  const staleKeys = data.slice(CLOUD_HISTORY_KEEP_COUNT).map((x) => x.key).filter(Boolean);
  if (!staleKeys.length) return;
  await supabase.from("app_state").delete().in("key", staleKeys);
}

function shouldIncludeKey(key, prefix = "") {
  if (!key) return false;
  if (prefix) return key.startsWith(prefix);
  return SYNC_KEYS.includes(key);
}

export function dumpLocalStorage(prefix = "") {
  const obj = {};
  for (let i = 0; i < localStorage.length; i++) {
    const k = localStorage.key(i);
    if (shouldIncludeKey(k, prefix)) obj[k] = localStorage.getItem(k);
  }
  return obj;
}

export function restoreLocalStorage(obj, prefix = "", options = {}) {
  const preserveKeys = new Set(Array.isArray(options.preserveKeys) ? options.preserveKeys : []);
  if (prefix) {
    const remove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const k = localStorage.key(i);
      if (k && k.startsWith(prefix) && !preserveKeys.has(k)) remove.push(k);
    }
    remove.forEach((k) => localStorage.removeItem(k));
  } else {
    SYNC_KEYS.forEach((k) => {
      if (!preserveKeys.has(k)) localStorage.removeItem(k);
    });
  }

  for (const [k, v] of Object.entries(obj || {})) {
    if (!shouldIncludeKey(k, prefix)) continue;
    if (preserveKeys.has(k)) continue;
    localStorage.setItem(k, v == null ? "" : String(v));
  }
}

export async function cloudBackup(prefix = "") {
  const payload = dumpLocalStorage(prefix);
  const summary = summarizePayload(payload);
  const userId = await getCurrentUserId();
  const historyKey = buildHistoryKey();

  const { data, error } = await supabase
    .from("app_state")
    .upsert(
      { key: CLOUD_KEY, value: payload, updated_at: new Date().toISOString() },
      { onConflict: "user_id,key" }
    )
    .select("updated_at")
    .maybeSingle();

  if (error) throw error;

  // Keep historical snapshots for rollback; best effort and non-blocking for the main backup.
  try {
    await supabase
      .from("app_state")
      .insert({ key: historyKey, value: payload, updated_at: new Date().toISOString() });
    await pruneCloudHistory();
  } catch (_) {}

  return {
    userId,
    ...summary,
    updatedAt: data?.updated_at || "",
    historyKey,
    historyKeepCount: CLOUD_HISTORY_KEEP_COUNT
  };
}

export async function cloudRestore(prefix = "") {
  const userId = await getCurrentUserId();
  const { data, error } = await supabase
    .from("app_state")
    .select("value,updated_at")
    .eq("key", CLOUD_KEY)
    .maybeSingle();

  if (error) throw error;
  if (!data?.value) throw new Error("クラウドにバックアップがありません。先にバックアップしてね。");

  restoreLocalStorage(data.value, prefix);
  return {
    userId,
    ...summarizePayload(data.value),
    updatedAt: data?.updated_at || ""
  };
}

export function clearSyncedLocalState(prefix = "") {
  restoreLocalStorage({}, prefix);
}

function hasLocalSyncedKeys(prefix = "") {
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (shouldIncludeKey(key, prefix)) return true;
  }
  return false;
}

export async function hydrateCloudState({ force = false, prefix = "", preserveKeys = [] } = {}) {
  if (!force && hasLocalSyncedKeys(prefix)) {
    return { restored: false, reason: "local_data_exists" };
  }
  const { data, error } = await supabase
    .from("app_state")
    .select("value")
    .eq("key", CLOUD_KEY)
    .maybeSingle();

  if (error) throw error;
  if (!data?.value || typeof data.value !== "object") {
    return { restored: false, reason: "cloud_data_missing" };
  }

  restoreLocalStorage(data.value, prefix, { preserveKeys });
  return { restored: true, reason: "restored" };
}

export function getLastSyncedUserId() {
  return localStorage.getItem(LAST_SYNC_USER_KEY) || "";
}

export function setLastSyncedUserId(userId) {
  if (!userId) {
    localStorage.removeItem(LAST_SYNC_USER_KEY);
    return;
  }
  localStorage.setItem(LAST_SYNC_USER_KEY, String(userId));
}

async function runBackup() {
  if (inFlight) {
    pendingAfterFlight = true;
    return inFlightPromise || Promise.resolve();
  }

  inFlight = true;
  inFlightPromise = (async () => {
    try {
      await cloudBackup();
      dirtySinceLastBackup = false;
    } catch (_) {
      // Non-blocking autosave: silently ignore transient errors.
    } finally {
      inFlight = false;
      inFlightPromise = null;
      if (pendingAfterFlight) {
        pendingAfterFlight = false;
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          debounceTimer = null;
          runBackup();
        }, debounceMs);
      }
    }
  })();
  return inFlightPromise;
}

export function setCloudSyncPaused(paused) {
  syncPaused = !!paused;
}

export function requestCloudBackup({ immediate = false } = {}) {
  if (immediate) {
    if (debounceTimer) {
      clearTimeout(debounceTimer);
      debounceTimer = null;
    }
    return (async () => {
      await runBackup();
      if (dirtySinceLastBackup || pendingAfterFlight) {
        pendingAfterFlight = false;
        await runBackup();
      }
    })();
  }

  if (debounceTimer) clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    debounceTimer = null;
    runBackup();
  }, debounceMs);

  return Promise.resolve();
}

export function ensureCloudSyncRuntime({ debounce = 5000 } = {}) {
  debounceMs = Math.max(1000, Number(debounce) || 5000);
  if (autoSyncInstalled) return;

  const originalSetItem = Storage.prototype.setItem;
  const originalRemoveItem = Storage.prototype.removeItem;
  const originalClear = Storage.prototype.clear;

  Storage.prototype.setItem = function patchedSetItem(key, value) {
    const result = originalSetItem.call(this, key, value);
    if (!syncPaused && this === localStorage && shouldIncludeKey(String(key || ""))) {
      dirtySinceLastBackup = true;
      requestCloudBackup({ immediate: false });
    }
    return result;
  };

  Storage.prototype.removeItem = function patchedRemoveItem(key) {
    const result = originalRemoveItem.call(this, key);
    if (!syncPaused && this === localStorage && shouldIncludeKey(String(key || ""))) {
      dirtySinceLastBackup = true;
      requestCloudBackup({ immediate: false });
    }
    return result;
  };

  Storage.prototype.clear = function patchedClear() {
    const hadAny = SYNC_KEYS.some((k) => this.getItem(k) !== null);
    const result = originalClear.call(this);
    if (!syncPaused && this === localStorage && hadAny) {
      dirtySinceLastBackup = true;
      requestCloudBackup({ immediate: false });
    }
    return result;
  };

  const flushIfNeeded = () => {
    if (!shouldFlushOnPageLeave()) return;
    if (syncPaused || !dirtySinceLastBackup) return;
    requestCloudBackup({ immediate: true });
  };
  window.addEventListener("pagehide", flushIfNeeded);
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") flushIfNeeded();
  });

  autoSyncInstalled = true;
}
